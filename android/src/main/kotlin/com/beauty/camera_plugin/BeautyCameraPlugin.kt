// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v25.3.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package com.beauty.camera_plugin

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
import io.flutter.embedding.engine.plugins.FlutterPlugin
import io.flutter.embedding.engine.plugins.activity.ActivityAware
import io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding
import io.flutter.plugin.common.PluginRegistry.Registrar

private object BeautyCameraPluginPigeonUtils {

  fun createConnectionError(channelName: String): FlutterError {
    return FlutterError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")  }

  fun wrapResult(result: Any?): List<Any?> {
    return listOf(result)
  }

  fun wrapError(exception: Throwable): List<Any?> {
    return if (exception is FlutterError) {
      listOf(
        exception.code,
        exception.message,
        exception.details
      )
    } else {
      listOf(
        exception.javaClass.simpleName,
        exception.toString(),
        "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
      )
    }
  }
  fun deepEquals(a: Any?, b: Any?): Boolean {
    if (a is ByteArray && b is ByteArray) {
        return a.contentEquals(b)
    }
    if (a is IntArray && b is IntArray) {
        return a.contentEquals(b)
    }
    if (a is LongArray && b is LongArray) {
        return a.contentEquals(b)
    }
    if (a is DoubleArray && b is DoubleArray) {
        return a.contentEquals(b)
    }
    if (a is Array<*> && b is Array<*>) {
      return a.size == b.size &&
          a.indices.all{ deepEquals(a[it], b[it]) }
    }
    if (a is List<*> && b is List<*>) {
      return a.size == b.size &&
          a.indices.all{ deepEquals(a[it], b[it]) }
    }
    if (a is Map<*, *> && b is Map<*, *>) {
      return a.size == b.size && a.all {
          (b as Map<Any?, Any?>).containsKey(it.key) &&
          deepEquals(it.value, b[it.key])
      }
    }
    return a == b
  }
      
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/** Represents the available filter types for camera effects */
enum class FilterType(val raw: Int) {
  /** No filter applied */
  NONE(0),
  /** Beauty filter for skin smoothing */
  BEAUTY(1),
  /** Vintage effect filter */
  VINTAGE(2),
  /** Black and white filter */
  BLACK_AND_WHITE(3),
  /** Custom filter with parameters */
  CUSTOM(4);

  companion object {
    fun ofRaw(raw: Int): FilterType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Represents possible camera error types */
enum class CameraErrorType(val raw: Int) {
  /** Camera initialization failed */
  INITIALIZATION_FAILED(0),
  /** Camera permission denied */
  PERMISSION_DENIED(1),
  /** Camera hardware not available */
  HARDWARE_NOT_AVAILABLE(2),
  /** Invalid camera settings */
  INVALID_SETTINGS(3),
  /** Recording failed */
  RECORDING_FAILED(4),
  /** Picture capture failed */
  CAPTURE_FAILED(5),
  /** Unknown error occurred */
  UNKNOWN(6);

  companion object {
    fun ofRaw(raw: Int): CameraErrorType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Configuration settings for camera initialization
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CameraSettings (
  /**
   * The desired width of the camera preview in pixels
   * If null, the default camera resolution will be used
   */
  val width: Long? = null,
  /**
   * The desired height of the camera preview in pixels
   * If null, the default camera resolution will be used
   */
  val height: Long? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CameraSettings {
      val width = pigeonVar_list[0] as Long?
      val height = pigeonVar_list[1] as Long?
      return CameraSettings(width, height)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      width,
      height,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is CameraSettings) {
      return false
    }
    if (this === other) {
      return true
    }
    return BeautyCameraPluginPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Configuration for applying filters to the camera preview
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class FilterConfig (
  /** The type of filter to apply */
  val filterType: String? = null,
  /**
   * Additional parameters for the filter
   * The structure depends on the filter type:
   * - For beauty filter: {'smoothness': 0.0-1.0, 'brightness': 0.0-1.0}
   * - For vintage: {'intensity': 0.0-1.0}
   * - For custom: varies based on implementation
   */
  val parameters: Map<String, Any?>? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): FilterConfig {
      val filterType = pigeonVar_list[0] as String?
      val parameters = pigeonVar_list[1] as Map<String, Any?>?
      return FilterConfig(filterType, parameters)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      filterType,
      parameters,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is FilterConfig) {
      return false
    }
    if (this === other) {
      return true
    }
    return BeautyCameraPluginPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Represents a camera error with type and message
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CameraError (
  /** The type of error that occurred */
  val type: CameraErrorType,
  /** A human-readable description of the error */
  val message: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CameraError {
      val type = pigeonVar_list[0] as CameraErrorType
      val message = pigeonVar_list[1] as String
      return CameraError(type, message)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      type,
      message,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is CameraError) {
      return false
    }
    if (this === other) {
      return true
    }
    return BeautyCameraPluginPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}
private open class BeautyCameraPluginPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          FilterType.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          CameraErrorType.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CameraSettings.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          FilterConfig.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CameraError.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is FilterType -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is CameraErrorType -> {
        stream.write(130)
        writeValue(stream, value.raw)
      }
      is CameraSettings -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is FilterConfig -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is CameraError -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}


/**
 * Host API for camera operations
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface BeautyCameraHostApi {
  /**
   * Initializes the camera with the specified settings
   *
   * Returns a Future that completes when the camera is initialized
   * Throws [CameraException] if initialization fails
   */
  fun initializeCamera(settings: CameraSettings, callback: (Result<Unit>) -> Unit)
  /**
   * Creates a new preview texture and returns its ID
   *
   * Returns the texture ID that can be used to display the camera preview
   * Returns null if texture creation fails
   */
  fun createPreviewTexture(callback: (Result<Long?>) -> Unit)
  /**
   * Starts the camera preview on the specified texture
   *
   * [textureId] must be a valid texture ID returned by [createPreviewTexture]
   */
  fun startPreview(textureId: Long, callback: (Result<Unit>) -> Unit)
  /** Stops the camera preview */
  fun stopPreview(callback: (Result<Unit>) -> Unit)
  /** Disposes of all camera resources */
  fun disposeCamera(callback: (Result<Unit>) -> Unit)
  /**
   * Takes a picture and saves it to the specified path
   *
   * [path] must be a valid file path where the image will be saved
   */
  fun takePicture(path: String, callback: (Result<Unit>) -> Unit)
  /**
   * Starts recording video to the specified path
   *
   * [path] must be a valid file path where the video will be saved
   */
  fun startRecording(path: String, callback: (Result<Unit>) -> Unit)
  /** Stops the current video recording */
  fun stopRecording(callback: (Result<Unit>) -> Unit)
  /**
   * Applies a filter to the camera preview
   *
   * [textureId] must be a valid texture ID
   * [filterConfig] specifies the filter type and parameters
   */
  fun applyFilter(textureId: Long, filterConfig: FilterConfig, callback: (Result<Unit>) -> Unit)

  companion object {
    /** The codec used by BeautyCameraHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      BeautyCameraPluginPigeonCodec()
    }
    /** Sets up an instance of `BeautyCameraHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: BeautyCameraHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.beauty.camera_plugin.BeautyCameraHostApi.initializeCamera$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as CameraSettings
            api.initializeCamera(settingsArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapError(error))
              } else {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.beauty.camera_plugin.BeautyCameraHostApi.createPreviewTexture$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.createPreviewTexture{ result: Result<Long?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(BeautyCameraPluginPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.beauty.camera_plugin.BeautyCameraHostApi.startPreview$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val textureIdArg = args[0] as Long
            api.startPreview(textureIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapError(error))
              } else {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.beauty.camera_plugin.BeautyCameraHostApi.stopPreview$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.stopPreview{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapError(error))
              } else {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.beauty.camera_plugin.BeautyCameraHostApi.disposeCamera$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.disposeCamera{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapError(error))
              } else {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.beauty.camera_plugin.BeautyCameraHostApi.takePicture$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pathArg = args[0] as String
            api.takePicture(pathArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapError(error))
              } else {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.beauty.camera_plugin.BeautyCameraHostApi.startRecording$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pathArg = args[0] as String
            api.startRecording(pathArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapError(error))
              } else {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.beauty.camera_plugin.BeautyCameraHostApi.stopRecording$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.stopRecording{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapError(error))
              } else {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.beauty.camera_plugin.BeautyCameraHostApi.applyFilter$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val textureIdArg = args[0] as Long
            val filterConfigArg = args[1] as FilterConfig
            api.applyFilter(textureIdArg, filterConfigArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapError(error))
              } else {
                reply.reply(BeautyCameraPluginPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * Flutter API for camera events
 *
 * Generated class from Pigeon that represents Flutter messages that can be called from Kotlin.
 */
class BeautyCameraFlutterApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by BeautyCameraFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      BeautyCameraPluginPigeonCodec()
    }
  }
  /**
   * Called when the camera is successfully initialized
   *
   * [textureId] is the ID of the preview texture
   * [width] and [height] are the actual dimensions of the camera preview
   */
  fun onCameraInitialized(textureIdArg: Long, widthArg: Long, heightArg: Long, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.com.beauty.camera_plugin.BeautyCameraFlutterApi.onCameraInitialized$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(textureIdArg, widthArg, heightArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(BeautyCameraPluginPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Called when a picture has been taken and saved
   *
   * [path] is the path where the image was saved
   */
  fun onTakePictureCompleted(pathArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.com.beauty.camera_plugin.BeautyCameraFlutterApi.onTakePictureCompleted$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pathArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(BeautyCameraPluginPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  /** Called when video recording has started */
  fun onRecordingStarted(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.com.beauty.camera_plugin.BeautyCameraFlutterApi.onRecordingStarted$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(BeautyCameraPluginPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Called when video recording has stopped
   *
   * [path] is the path where the video was saved
   */
  fun onRecordingStopped(pathArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.com.beauty.camera_plugin.BeautyCameraFlutterApi.onRecordingStopped$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pathArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(BeautyCameraPluginPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Called when a camera error occurs
   *
   * [error] contains both the type and message of the error
   */
  fun onCameraError(errorArg: CameraError, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.com.beauty.camera_plugin.BeautyCameraFlutterApi.onCameraError$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(errorArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(BeautyCameraPluginPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}

/** Main plugin class that delegates to BeautyCameraPluginImpl */
class BeautyCameraPlugin: FlutterPlugin, ActivityAware {
    private var impl: BeautyCameraPluginImpl? = null

    override fun onAttachedToEngine(binding: FlutterPlugin.FlutterPluginBinding) {
        impl = BeautyCameraPluginImpl()
        impl?.onAttachedToEngine(binding)
    }

    override fun onDetachedFromEngine(binding: FlutterPlugin.FlutterPluginBinding) {
        impl?.onDetachedFromEngine(binding)
        impl = null
    }

    override fun onAttachedToActivity(binding: ActivityPluginBinding) {
        impl?.onAttachedToActivity(binding)
    }

    override fun onDetachedFromActivity() {
        impl?.onDetachedFromActivity()
    }

    override fun onReattachedToActivityForConfigChanges(binding: ActivityPluginBinding) {
        impl?.onReattachedToActivityForConfigChanges(binding)
    }

    override fun onDetachedFromActivityForConfigChanges() {
        impl?.onDetachedFromActivityForConfigChanges()
    }

    companion object {
        @JvmStatic
        fun registerWith(registrar: Registrar) {
            BeautyCameraPluginImpl.registerWith(registrar)
        }
    }
}
